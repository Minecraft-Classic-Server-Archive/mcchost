#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <errno.h>
#include <time.h>
#include <ctype.h>
#include <assert.h>
#include <sys/socket.h>
#include <netinet/in.h>

// Note: This header is generated by "makeheaders"
// Currently: https://fossil-scm.org/home/file/src/makeheaders.c
#include "main.h"

int line_ofd = -1;
int line_ifd = -1;
char inbuf[4096];
int insize = 0, inptr = 0;

char user_id[NB_SLEN];
int user_authenticated = 0;
int server_id_op_flag = 1;
int inetd_mode = 0;
int start_tcp_server = 0;
int enable_heartbeat_poll = 0;
int tcp_port_no = 25565;

char program_name[512];

char server_software[NB_SLEN] = "MCCHost";
char server_name[NB_SLEN] = "MCCHost Server";
char server_motd[NB_SLEN] = "";
char server_secret[NB_SLEN] = "";
char client_software[NB_SLEN] = "(unknown)";

char heartbeat_url[1024] = "http://www.classicube.net/server/heartbeat/";
int server_private = 0;
int server_runonce = 0;
int save_conf = 0;

int cpe_disabled = 0;	// Set if disabled on the server
int cpe_enabled = 0;	// Set if this session is using CPE
int cpe_requested = 0;	// Set if cpe was requested, even if rejected.
int cpe_pending = 0;	// Currently running ExtInfo process.
int cpe_extn_remaining = 0;

block_t max_blockno_to_send = 49;
int enable_cp437 = 0;

char * level_name = "main";

char * proc_args_mem = 0;
int    proc_args_len = 0;

int
main(int argc, char **argv)
{
    snprintf(program_name, sizeof(program_name), "%s", argv[0]);

    process_args(argc, argv);
    proc_args_mem = argv[0];
    proc_args_len = argv[argc-1] + strlen(argv[argc-1]) - argv[0];
    memset(proc_args_mem, 0, proc_args_len);

    load_ini_file(system_ini_fields, SERVER_CONF_NAME, 1);

    if (!inetd_mode && !start_tcp_server && (isatty(0) || isatty(1)))
	show_args_help();

    if (save_conf)
	save_ini_file(system_ini_fields, SERVER_CONF_NAME);

    init_dirs();

    if (start_tcp_server) {
	memset(proc_args_mem, 0, proc_args_len);
	snprintf(proc_args_mem, proc_args_len, "%s port %d", server_software, tcp_port_no);

	open_logfile();
	tcpserver();

	// Reload, changes?
	load_ini_file(system_ini_fields, SERVER_CONF_NAME, 1);
    } else {
	line_ofd = 1; line_ifd = 0;
    }

    process_connection();
    run_request_loop();
    send_disconnect_message();
    stop_user();
    return 0;
}

void
process_connection()
{
    open_logfile();
    open_client_list();

    login();

    memset(proc_args_mem, 0, proc_args_len);
    snprintf(proc_args_mem, proc_args_len, "%s (%s)", server_software, user_id);

    // If in classic mode, don't allow place of bedrock.
    if (!cpe_requested) server_id_op_flag = 0;

    if (cpe_requested && !cpe_disabled) {
	send_ext_list();
	cpe_pending = 1;
    }

    if (!cpe_pending)
	complete_connection();

    cpe_enabled = (cpe_requested && !cpe_disabled);
}

void
complete_connection()
{
    if (extn_evilbastard)
	fatal("Server is incompatible with Evil bastard extension");

    send_server_id_pkt(server_name, server_motd, server_id_op_flag);
    cpe_pending = 0;

    // List of users
    start_user();

    // Chat to users
    create_chat_queue();

    // Open level mmap files.
    open_level_files(level_name, 0);
    send_map_file();
    send_spawn_pkt(255, user_id, level_prop->spawn);
    send_welcome_message();

    if (extn_clickdistance && level_prop->click_distance > 0)
	send_clickdistance_pkt(level_prop->click_distance);
}

/*HELP Welcome 0 */
void
send_welcome_message()
{
    char buf[256];
    sprintf(buf, "&eWelcome &7%s", user_id);
    send_message_pkt(0, buf);
    sprintf(buf, "&a+ &7%s &econnected", user_id);
    post_chat(0, buf, strlen(buf));
    cmd_help("welcome", 0);
}

void
send_disconnect_message()
{
    char buf[256];
    sprintf(buf, "&c- &7%s &edisconnected", user_id);
    post_chat(0, buf, strlen(buf));
    sprintf(buf, "Connection dropped for %s", user_id);
    print_logfile(buf);
}

void
login()
{
    time_t startup = time(0);
    fcntl(line_ifd, F_SETFL, (int)O_NONBLOCK);
    while(insize-inptr < 131)
    {
	int cc = read(line_ifd, inbuf+insize, sizeof(inbuf)-insize);
	if (cc>0) insize += cc;
	if (cc<=0) {
	    if (errno != EAGAIN && errno != EINTR) {
		if (insize == 0)
		    teapot();
		else
		    quiet_drop("Short connection received");
	    }
	    time_t now = time(0);
	    if (now-startup > 4) {
		if (insize == 0) {
		    teapot();
		} else
		    quiet_drop("Short logon packet received");
	    } else
		usleep(50000);
	}

	if (insize >= 1 && inbuf[inptr] != 0) // Special exit for weird caller.
	    teapot();
	if (insize >= 2 && inbuf[inptr+1] != 7) {
	    if (inbuf[inptr+1] == 0)
		teapot();
	    if (insize >= 66 && inbuf[inptr+1] > 0 && inbuf[inptr+1] < 7)
		cpy_nbstring(user_id, inbuf+2);
	    quiet_drop("Only protocol version seven is supported");
	}
    }
    fcntl(line_ifd, F_SETFL, 0);

    char mppass[NB_SLEN];
    cpy_nbstring(mppass, inbuf+64+2);
    cpy_nbstring(user_id, inbuf+2);

    for(int i = 0; user_id[i]; i++)
	if (!isascii(user_id[i]) ||
	    (!isalnum(user_id[i]) && user_id[i] != '.' && user_id[i] != '_')) {

	    for(i=0; user_id[i]; i++)
		if (user_id[i] <= ' ' || user_id[i] > '~')
		    user_id[i] = '*';
	    quiet_drop("Invalid user name");
	}

    {
	char buf[256];
	if (client_ipv4_port)
	    sprintf(buf, "Logging in user '%s' from %s:%d",
		user_id, client_ipv4_str, client_ipv4_port);
	else
	    sprintf(buf, "Logging in user '%s'", user_id);
	print_logfile(buf);
    }

    if (*server_secret != 0 && *server_secret != '-') {
	if (strlen(mppass) != 32)
	    if (!client_ipv4_localhost)
		quiet_drop("Login failed!");
	if (*user_id == 0) quiet_drop("Username must be entered");
    }

    if (strlen(user_id) > 16)
	quiet_drop("Usernames must be between 1 and 16 characters");

    cpe_requested = inbuf[inptr+128+2] == 0x42;

    if (*server_secret != 0 && *server_secret != '-') {
	char hashbuf[NB_SLEN*2];
	strcpy(hashbuf, server_secret);
	strcat(hashbuf, user_id);

	MD5_CTX mdContext;
	unsigned int len = strlen (hashbuf);
	MD5Init (&mdContext);
	MD5Update (&mdContext, (unsigned char *)hashbuf, len);
	MD5Final (&mdContext);

	for (int i = 0; i < 16; i++) {
	    sprintf(hashbuf+i*2, "%02x", mdContext.digest[i]);
	}

	if (strcasecmp(hashbuf, mppass) != 0) {
	    if (!client_ipv4_localhost)
		quiet_drop("Login failed! Close the game and sign in again.");
	}

	user_authenticated = 1;
    }

}

void
fatal(char * emsg)
{
    static int in_fatal = 0;
    assert(!in_fatal);
    in_fatal = 1;

    if (level_chat_queue) {
	char buf[256];
	sprintf(buf, "&c- &7%s &cCrashed: &e%s", user_id, emsg);
	post_chat(0, buf, strlen(buf));
    }
    disconnect(1, emsg);
}

void
logout(char * emsg)
{
    char buf[256];
    sprintf(buf, "&c- &7%s &e%s", user_id, emsg);
    post_chat(0, buf, strlen(buf));
    disconnect(0, emsg);
}

LOCAL void
quiet_drop(char * emsg)
{
    disconnect(0, emsg);
}

LOCAL void
teapot()
{
    if (line_ofd < 0) return;

    char buf[256];
    if (client_ipv4_port) {
	sprintf(buf, "Failed connect %s:%d, Invalid peer process",
	    client_ipv4_str, client_ipv4_port);
	print_logfile(buf);
    }

    strcpy(buf, "418 I'm a teapot\n");
    write_to_remote(buf, strlen(buf));
    flush_to_remote();
    shutdown(line_ofd, SHUT_RDWR);
    if (line_ofd != line_ifd)
	shutdown(line_ifd, SHUT_RDWR);
    exit(4);
}

LOCAL void
disconnect(int rv, char * emsg)
{
    if (line_ofd < 0) return;

    char buf[256];
    if (client_ipv4_port && *user_id)
	sprintf(buf, "Disconnect %s:%d, user '%s', %s",
	    client_ipv4_str, client_ipv4_port, user_id, emsg);
    else if (client_ipv4_port)
	sprintf(buf, "Disconnect %s:%d, %s",
	    client_ipv4_str, client_ipv4_port, emsg);
    else if (*user_id)
	sprintf(buf, "Disconnect user '%s', %s", user_id, emsg);
    else
	sprintf(buf, "Disconnect %s", emsg);
    print_logfile(buf);

    stop_user();
    send_discon_msg_pkt(emsg);
    flush_to_remote();
    shutdown(line_ofd, SHUT_RDWR);
    if (line_ofd != line_ifd)
	shutdown(line_ifd, SHUT_RDWR);
    exit(rv);
}

void
show_args_help()
{
    fprintf(stderr, "Usage: %s [-inetd|-tcp|-net] ...\n", program_name);
    fprintf(stderr, "  -inetd    Assume socket is stdin/out from inetd or similar\n");
    fprintf(stderr, "  -tcp      Open a tcp socket for listening, no default secret.\n");
    fprintf(stderr, "  -net      Open a socket, register secret at:\n%10s%s\n", "", heartbeat_url);
    fprintf(stderr, "  -port X   Set port number listened to.\n");
    fprintf(stderr, "  -dir X    Change to directory before opening data files.\n");
    fprintf(stderr, "  -private -public\n");
    fprintf(stderr, "            When registering set privacy state.\n");

    fprintf(stderr, "  -name X   Set server name\n");
    fprintf(stderr, "  -motd X   Set server motd\n");
    fprintf(stderr, "  -secret X\n");
    fprintf(stderr, "  -salt X   Set server salt/secret\n");
    fprintf(stderr, "  -heartbeat X\n");
    fprintf(stderr, "            Change hearbeat url\n");
    fprintf(stderr, "  -runonce  Accept a connection but don't fork, for debugging.\n");
    fprintf(stderr, "  -nocpe    Don't accept a CPE request.\n");
    fprintf(stderr, "  -saveconf Save current system conf in server.ini for next time.\n");

    exit(1);
}

void
cpy_nbstring(char *buf, char *str)
{
    memcpy(buf, str, MB_STRLEN);
    for(int i = 0; i<MB_STRLEN; i++) if (buf[i] == 0) buf[i] = ' ';
    buf[MB_STRLEN] = 0;
    char * p = buf+MB_STRLEN;
    while (p>buf && p[-1] == ' ') *(--p) = 0;
}
