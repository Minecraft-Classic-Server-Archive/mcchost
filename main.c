#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <errno.h>
#include <time.h>
#include <ctype.h>
#include <assert.h>
#include <sys/socket.h>
#include <netinet/in.h>

// Note: This header is generated by "makeheaders"
// Currently: https://fossil-scm.org/home/file/src/makeheaders.c
#include "main.h"

int line_ofd = -1;
int line_ifd = -1;
char inbuf[4096];
int insize = 0, inptr = 0;

char user_id[NB_SLEN];
int user_authenticated = 0;
int server_id_op_flag = 1;
int cpe_requested = 0;
int start_tcp_server = 0;
int enable_heartbeat_poll = 0;
int tcp_port_no = 25565;

char program_name[512];

char server_name[NB_SLEN] = "Some Random Server";
char server_motd[NB_SLEN] = "Welcome";
char server_secret[NB_SLEN] = "";
char heartbeat_url[1024] = "http://www.classicube.net/server/heartbeat/";
int server_private = 0;
int server_runonce = 0;

int cpe_enabled = 0;
block_t max_blockno_to_send = 49;
int enable_cp437 = 0;

void login(void);
void fatal(char * emsg);
void cpy_nbstring(char *buf, char *str);

char * level_name = "main";

char * proc_args_mem = 0;
int    proc_args_len = 0;

int
main(int argc, char **argv)
{
    snprintf(program_name, sizeof(program_name), "%s", argv[0]);
    process_args(argc, argv);
    proc_args_mem = argv[0];
    proc_args_len = argv[argc-1] + strlen(argv[argc-1]) - argv[0];
    memset(proc_args_mem, 0, proc_args_len);

    init_dirs();

    if (start_tcp_server) {
	memset(proc_args_mem, 0, proc_args_len);
	snprintf(proc_args_mem, proc_args_len, "MC server port %d", tcp_port_no);

	open_logfile();
	tcpserver();
    } else {
	line_ofd = 1; line_ifd = 0;
    }

    process_connection();
    run_request_loop();
    send_disconnect_message();
    stop_user();
    return 0;
}

void
process_connection()
{
    open_logfile();
    open_client_list();

    login();

    memset(proc_args_mem, 0, proc_args_len);
    snprintf(proc_args_mem, proc_args_len, "MC server (%s)", user_id);

    // If in classic mode, don't allow place of bedrock.
    if (!cpe_requested) server_id_op_flag = 0;

    // If client requests CPE, assume it'll be okay to send CPE blocks.
    if (cpe_requested && max_blockno_to_send < 65)
	max_blockno_to_send = 65;

    send_server_id_pkt(server_name, server_motd, server_id_op_flag);

    // List of users
    start_user();

    // Chat to users
    create_chat_queue();

    // Open level mmap files.
    open_level_files(level_name, 0);
    send_map_file();
    send_spawn_pkt(255, user_id, level_prop->spawn);
    send_welcome_message();
}

void
send_welcome_message()
{
    char buf[256];
    sprintf(buf, "&eWelcome &7%s", user_id);
    send_message_pkt(0, buf);
    sprintf(buf, "&a+ &7%s &econnected", user_id);
    post_chat(buf, strlen(buf));
}

void
send_disconnect_message()
{
    char buf[256];
    sprintf(buf, "&c- &7%s &edisconnected", user_id);
    post_chat(buf, strlen(buf));
    sprintf(buf, "Connection dropped for %s", user_id);
    print_logfile(buf);
}

void
login()
{
    time_t startup = time(0);
    fcntl(line_ifd, F_SETFL, (int)O_NONBLOCK);
    while(insize-inptr < 131)
    {
	int cc = read(line_ifd, inbuf+insize, sizeof(inbuf)-insize);
	if (cc>0) insize += cc;
	if (cc<=0) {
	    if (errno != EAGAIN && errno != EINTR) {
		if (insize == 0)
		    fatal("No data received");
		else
		    fatal("Short connection received");
	    }
	    time_t now = time(0);
	    if (now-startup > 4)
		fatal("Short logon packet received");
	    usleep(50000);
	}

	if (insize >= 1 && inbuf[inptr] != 0) // Special exit for weird caller.
	    fatal("418 I'm a teapot\n\n");
	if (insize >= 2 && inbuf[inptr+1] != 7)
	    fatal("Only protocol version seven is supported");
    }
    fcntl(line_ifd, F_SETFL, 0);

    char mppass[NB_SLEN];
    cpy_nbstring(mppass, inbuf+64+2);
    cpy_nbstring(user_id, inbuf+2);

    {
	char buf[256];
	if (client_ipv4_port)
	    sprintf(buf, "Logging in user '%s' from %s:%d",
		user_id, client_ipv4_str, client_ipv4_port);
	else
	    sprintf(buf, "Logging in user '%s'", user_id);
	print_logfile(buf);
    }

    if (*server_secret != 0 && *server_secret != '-') {
	if (strlen(mppass) != 32)
	    if (!client_ipv4_localhost)
		fatal("Login failed!");
	if (*user_id == 0) fatal("Username must be entered");
    }

    if (strlen(user_id) > 16)
	fatal("Usernames must be between 1 and 16 characters");

    for(int i = 0; user_id[i]; i++)
	if (!isascii(user_id[i]) ||
	    (!isalnum(user_id[i]) && user_id[i] != '.' && user_id[i] != '_'))
		fatal("Invalid user name");

    cpe_requested = inbuf[inptr+128+2] == 0x42;

    if (*server_secret != 0 && *server_secret != '-') {
	char hashbuf[NB_SLEN*2];
	strcpy(hashbuf, server_secret);
	strcat(hashbuf, user_id);

	MD5_CTX mdContext;
	unsigned int len = strlen (hashbuf);
	MD5Init (&mdContext);
	MD5Update (&mdContext, (unsigned char *)hashbuf, len);
	MD5Final (&mdContext);

	for (int i = 0; i < 16; i++) {
	    sprintf(hashbuf+i*2, "%02x", mdContext.digest[i]);
	}

	if (strcasecmp(hashbuf, mppass) != 0) {
	    if (!client_ipv4_localhost)
		fatal("Login failed! Close the game and sign in again.");
	}

	user_authenticated = 1;
    }

}

void
fatal(char * emsg)
{
    static int in_fatal = 0;
    assert(!in_fatal);
    in_fatal = 1;

    if (level_chat_queue) {
	char buf[256];
	sprintf(buf, "&c- &7%s &cCrashed: &e%s", user_id, emsg);
	post_chat(buf, strlen(buf));
    }
    disconnect(emsg);
}

void
kicked(char * emsg)
{
    char buf[256];
    sprintf(buf, "&c- &7%s &ekicked (%s)", user_id, emsg);
    post_chat(buf, strlen(buf));
    disconnect(emsg);
}

void
logout(char * emsg)
{
    char buf[256];
    sprintf(buf, "&c- &7%s &e%s", user_id, emsg);
    post_chat(buf, strlen(buf));
    disconnect(emsg);
}

void
disconnect(char * emsg)
{
    if (line_ofd < 0) return;

    char buf[256];
    if (client_ipv4_port && *user_id == 0)
	sprintf(buf, "Disconnect %s:%d, %s",
	    client_ipv4_str, client_ipv4_port, emsg);
    else
	sprintf(buf, "Disconnect user '%s', %s", user_id, emsg);
    print_logfile(buf);

    stop_user();
    send_discon_msg_pkt(emsg);
    flush_to_remote();
    shutdown(line_ofd, SHUT_RDWR);
    if (line_ofd != line_ifd)
	shutdown(line_ifd, SHUT_RDWR);
    exit(0);
}

void
cpy_nbstring(char *buf, char *str)
{
    memcpy(buf, str, MB_STRLEN);
    for(int i = 0; i<MB_STRLEN; i++) if (buf[i] == 0) buf[i] = ' ';
    buf[MB_STRLEN] = 0;
    char * p = buf+MB_STRLEN;
    while (p>buf && p[-1] == ' ') *(--p) = 0;
}
